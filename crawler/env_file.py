from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, Mapping


@dataclass(frozen=True)
class EnvFileUpdate:
    path: Path
    changed: bool


def _needs_quotes(value: str) -> bool:
    if value == "":
        return False
    return any(ch.isspace() for ch in value) or any(ch in value for ch in ['"', "'", "#"])


def _format_env_line(key: str, value: str) -> str:
    if _needs_quotes(value):
        escaped = value.replace("\\", "\\\\").replace('"', '\\"')
        return f'{key}="{escaped}"'
    return f"{key}={value}"


def _parse_key(line: str) -> str | None:
    stripped = line.strip()
    if not stripped or stripped.startswith("#"):
        return None
    if stripped.startswith("export "):
        stripped = stripped[len("export ") :].lstrip()
    if "=" not in stripped:
        return None
    key = stripped.split("=", 1)[0].strip()
    return key or None


def read_env_file(path: Path) -> dict[str, str]:
    path = Path(path)
    if not path.exists():
        return {}

    out: dict[str, str] = {}
    for raw in path.read_text(encoding="utf-8").splitlines():
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        if line.startswith("export "):
            line = line[len("export ") :].lstrip()
        if "=" not in line:
            continue
        key, value = line.split("=", 1)
        key = key.strip()
        value = value.strip()
        if not key:
            continue
        if len(value) >= 2 and value[0] == value[-1] and value[0] in ("'", '"'):
            value = value[1:-1]
            if value and value[0] == '"':
                # no-op (kept for clarity)
                pass
            value = value.replace('\\"', '"').replace("\\\\", "\\")
        out[key] = value
    return out


def load_env_file(path: Path) -> EnvFileUpdate:
    import os

    values = read_env_file(path)
    changed = False
    for k, v in values.items():
        if k not in os.environ:
            os.environ[k] = v
            changed = True
    return EnvFileUpdate(path=Path(path), changed=changed)


def upsert_env_file(path: Path, values: Mapping[str, str]) -> EnvFileUpdate:
    path = Path(path)
    existing = path.read_text(encoding="utf-8").splitlines() if path.exists() else []

    keys = set(values.keys())
    out: list[str] = []
    seen: set[str] = set()
    changed = False

    for line in existing:
        key = _parse_key(line)
        if key and key in keys:
            out.append(_format_env_line(key, values[key]))
            seen.add(key)
            changed = True
        else:
            out.append(line)

    missing = [k for k in values.keys() if k not in seen]
    if missing:
        if out and out[-1].strip() != "":
            out.append("")
        out.append("# Generated by capture script")
        for k in missing:
            out.append(_format_env_line(k, values[k]))
        changed = True

    if changed:
        path.write_text("\n".join(out).rstrip() + "\n", encoding="utf-8")

    return EnvFileUpdate(path=path, changed=changed)


def redact_dict(values: Mapping[str, str], *, head: int = 12, tail: int = 6) -> dict[str, str]:
    def mask(v: str) -> str:
        if not v:
            return ""
        if len(v) <= head + tail + 1:
            return v[:2] + "…"
        return f"{v[:head]}…{v[-tail:]}"

    return {k: mask(v) if "TOKEN" in k or "COOKIE" in k else v for k, v in values.items()}
